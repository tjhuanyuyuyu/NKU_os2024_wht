<h1 align="center" style="border: none;"><strong>操作系统Lab3实验报告</strong></h1>

<h2 align="center" style="border: none;">成员：涂佳欢语  王婷睿  胡可玉</h2>

 
## **零、练习0：填写已有实验**  
本实验依赖实验1/2。将实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

## **一、练习1：理解基于FIFO的页面替换算法（思考题）**   

先简要说明一下在进行页面置换之前经过的流程：

**流程图**

```
exception_handler → pgfault_handler → do_pgfault → swap_in
```

**过程概述**：
1. **`exception_handler`**：`exception_handler` 是ucore中用于处理异常的入口函数，它会根据异常的类型（如页错误、非法指令等）选择不同的处理逻辑。当发生页面错误时，函数会调用 `pgfault_handler` 来处理页错误。
2. **`pgfault_handler`**：`pgfault_handler` 负责处理页面错误。它会检查 `check_mm_struct` 是否为空，也就是检查当前是否存在一个有效的进程内存结构，如果是，系统就调用 `do_pgfault` 为该进程处理页错误。
3. **`do_pgfault`**： `do_pgfault` 处理具体的页面错误。它首先调用 `find_vma` 查找 `addr` （即访问出错的虚拟地址）所在的虚拟内存区域（VMA），根据 VMA 的权限，设置页面的访问权限，然后将 `addr` 对齐到页面边界；接着通过 `get_pte` 获取页表项，如果页表项为空，调用 `pgdir_alloc_page` 为该地址分配一个新的页面并更新页表项，如果页表项是一个交换条目且页面置换算法准备就绪，就调用 `swap_in` 函数从磁盘加载页面，更新页表项，并将页面标记为可交换。

在进入 `do_pgfault` 之后，当页表项（PTE）已经存在且指向一个交换条目时，系统将调用 `swap_in`，开始进行页面置换。

**在页面置换的过程中，包括 `swap_in` 函数在内，调用了以下函数和宏**：

1. **`swap_in()`**：`swap_in()`的核心功能是从磁盘的交换空间加载被交换出去的页面，并将它们恢复到物理内存中。它首先分配一个物理页面，接着根据页表项读取磁盘上的数据，并将数据加载到物理内存。最后，它通过引用传递将 `Page` 更新为新加载的物理内存页。

2. **`alloc_page()`**：`alloc_pages` 函数用于从物理内存管理器（PMM，Physical Memory Manager）中分配多页物理内存。它尝试分配 `n` 页内存，并在内存不足且 `n=1` 且交换空间已经成功初始化时触发页面交换（swap-out）操作，将不活跃的页面换出到磁盘。该函数通过 `while (1)` 无限循环来尝试分配页面，在每次尝试分配页面前，它通过 `local_intr_save(intr_flag)` 保存当前的中断状态，以确保在页面分配过程中禁止中断（防止中断造成的并发问题），然后调用 `pmm_manager->alloc_pages(n)` 来分配 `n` 页的物理内存，完成分配后，通过 `local_intr_restore(intr_flag)` 恢复之前保存的中断状态；如果内存不足以分配n个页面且交换空间已经成功初始化且 `n=1` 时，将会调用`swap_out` 函数执行页面换出操作，把不常用的页面从内存中换出到磁盘上的交换空间，这里要求 `n=1` 是因为换出页面时不能换出连续的页面。

3. **`swap_out()`**：`swap_out` 函数的作用是将页面从物理内存交换到磁盘上的交换空间中。当物理内存不足时，`swap_out` 会选择一个合适的页面，将其保存到磁盘的交换空间以腾出空间给新的页面，并更新相关的页面表项，确保系统能够正确地恢复这个页面。

4. **`_fifo_swap_out_victim()`**：在 `swap_out` 函数中，调用了`swap_out_victim`函数，因为此时采用的页面置换算法是FIFO，所以这个函数也就是`_fifo_swap_out_victim()` 函数，它的作用是选择一个队列中最先进入的页面（即最早到达的页面）作为“牺牲者”页面，准备将其交换出去，它从页面队列中删除该页面，并返回该页面的指针。

5. **`get_pte()`**：在 `swap_out` 函数中调用，根据进程的目录页和在`swap_out_victim`函数中得到的被选中换出的页的虚拟地址，查找该虚拟地址对应的页表项（PTE）。

6. **`assert()`**：紧跟在`get_pte()`函数后的`assert()`函数是为了验证当前页表项（PTE）是否有效，即检查虚拟地址 `v` 是否已经映射到物理页面，如果页表项无效，就会立即报告错误并中止执行。

7. **`swapfs_write()`**：在 `swap_out` 函数中调用，将准备换出的页面数据写入到磁盘中，也就是将这个页面保存到磁盘。

8. **`map_swappable()`**：在 `swap_out` 函数中调用，如果`swapfs_write()`函数调用失败，意味着页面并没有成功地保存到磁盘上，这会影响整个页面交换机制的正常运作。因此，需要调用 `map_swappable()`将该页面恢复到可交换的状态，因为此时采用的页面置换算法是FIFO，所以这个函数也就是`_fifo_map_swappable` 函数，它将页面 `page` 插入到交换队列 `head` 中，帮助更新页面的状态以及记录页面的访问顺序。

9.  **`free_page()`**：在 `swap_out` 函数中调用，`free_page()` 函数的功能是释放一块连续的物理内存，因为此时页面已经成功保存到磁盘上的交换空间，所以该页面的物理内存可以回收。

10. **`tlb_invalidate()`**：由于页表改变了，这个函数用于刷新TLB。

11. **`get_pte()`**：回到 `swap_in` 函数，这是在 `swap_in` 函数中调用的`get_pte()`，它在这里查找的是访问出错的虚拟地址在页表中对应的页表项，这个页表项可能并没有指向物理内存中的一个页面，而是指向磁盘的交换空间。

12. **`swapfs_read()`**：通过页表项中存储的信息，读取磁盘中的数据，将其载入到目标物理内存页面（`result`）中。


## **二、练习2：深入理解不同分页模式的工作原理（思考题）**  
get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
 - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
 - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？
### 2.1 sv32，sv39，sv48格式
```plaintext
1. Sv32 虚拟地址格式：
+---------10---------+---------10---------+---------12---------+
|      VPN[1]        |      VPN[0]        |       PGOFF        |
+---------------------+--------------------+--------------------+
2. Sv39 虚拟地址格式：
+---------9---------+---------9---------+---------9---------+---------12---------+
|     VPN[2]       |      VPN[1]      |      VPN[0]      |        PGOFF        |
+-------------------+------------------+------------------+----------------------+
3. Sv48 虚拟地址格式：
+---------9---------+---------9---------+---------9---------+---------9---------+---------12---------+
|     VPN[3]       |      VPN[2]      |      VPN[1]      |      VPN[0]      |       PGOFF        |
+-------------------+------------------+------------------+------------------+----------------------+
```

### 2.2 get_pte()函数中两段代码相似原因：
`get_pte()` 中的两段代码分别处理第一级页表项（pdep1）和第二级页表项（pdep0），但都在执行类似的任务：检查页表项是否存在，如果不存在，则分配一个新的页表。在分页机制中，页表层次结构用于逐级查找线性地址映射的物理页。
1. 分页机制的层次结构
    1. 在分页机制中，每一级页表都通过某些索引访问到对应的表项。如果表项不存在或无效，需要分配新的页表页。
    2. 在分页机制中，各级页表的结构和逻辑非常相似，只是级数不同，访问的索引和线性地址的分段不同。
2. 代码设计的通用性：
    1. sv32、sv39、sv48都是多级页表且每一级的表项格式都相似。只是sv32最多2 级页表，sv39最多 3 级页表，sv48最多 4 级页表。
    2. 不论级数如何，逐级解析线性地址到物理地址的逻辑是相同的。所以`get_pte()`使用递归的两段代码实现逐级查找与分配,这种设计可扩展到更多级别的分页。

### 2.3 get_pte()函数将页表项的查找和页表项的分配合并在一个函数：
1. 优点：
    1. 简化接口：
    （1）一个函数实现不用分别调用“查找”和“分配”两个接口
    （2）调用时候隐藏了页表层次结构的细节，代码更简洁，调用出错率更低
    2. 如果频繁地需要同时进行查找和分配操作，合并在一个函数中可能会减少函数调用的开销。

2. 缺点：
    1. 灵活性降低：如果未来需要修改查找或分配的逻辑，将它们分开可以减少对另一个功能的干扰。
    2. 代码的可读性和可维护性降低：将不同的功能（查找和分配）分离到不同的函数中可读性和可维护性更高

3. 是否要拆开：
取决于使用的具体场景、需求和偏好。
 1. 拆开：
    1. 功能单一性：单一职责的函数更容易被扩展和调试。
    2. 如果查找和分配逻辑在其他地方也需要使用，独立的函数可以被单独调用，而不需要复制整个get_pte()函数的代码。
    3. 如果查找和分配需要不同的错误处理逻辑，分开的函数可以为每种情况提供专门的错误处理。
 2. 不拆开：如果大部分情况下调用 get_pte() 都需要同时支持查找和分配。

## **三、练习3：给未被映射的地址映射上物理页（需要编程）** 

### 3.1设计实现过程 
首先需要知道 `do_pgfault` 函数的具体功能： `do_pgfault` 处理具体的页面错误。它首先调用 `find_vma` 查找 `addr` （即访问出错的虚拟地址）所在的虚拟内存区域（VMA），根据 VMA 的权限，设置页面的访问权限，然后将 `addr` 对齐到页面边界；接着通过 `get_pte` 获取页表项，如果页表项为空，调用 `pgdir_alloc_page` 为该地址分配一个新的页面并更新页表项，如果页表项是一个交换条目且页面置换算法准备就绪，就调用 `swap_in` 函数从磁盘加载页面，更新页表项，并将页面标记为可交换。

我们所要填写的部分即为：当页表项是一个交换条目且页面置换算法准备就绪时，应该进行什么操作。根据缺页异常和页面置换的相关知识以及注释提示，我们认为这里应该完成如下三个操作，分别是：

1.将正确的磁盘页面内容加载到内存中。

```c++
swap_in(mm, addr, &page);
```

这里通过 `swap_in` 函数，从交换空间将 `addr` 所对应的磁盘页数据读取到 `page` 所指向的内存页中，`mm` 指定了进程，`addr` 是访问出错的虚拟地址，`&page` 是存放加载页面的指针。


2.设置物理地址和逻辑地址的映射。

```c++
page_insert(mm->pgdir, page, addr, perm); 
```

通过 `page_insert` 函数在页表中为 `addr` 实现了虚拟地址到物理地址的映射，将它指向物理页面 `page`，同时还会根据 `perm` 设置访问权限，`mm->pgdir` 是进程的页目录，`page` 是新分配的物理内存页面，`addr` 是访问出错的虚拟地址，`perm` 是访问权限。

3.将页面标记为可交换。

```c++
swap_map_swappable(mm,addr,page,1);
```

通过 `swap_map_swappable` 函数设置页面的交换状态，将页面标记为可以被交换到磁盘。


### 3.2请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处

1. **PPN (Physical Page Number)**:
指向物理页面的物理地址，页替换算法需要知道物理页面的具体位置以便在内存不足时替换该页，或者在缺页时将页面加载到内存中的合适位置。

2. **V (Valid)**:
页替换算法可以使用该位来判断页面是否有效。无效的页表项可以直接用于新页面的映射，无需进行额外的替换处理。

3. **R (Read)**, **W (Write)**, **X (Execute)**:
页替换算法可以根据这些权限来选择替换的页面。例如，有些算法可能会优先替换掉仅读或仅执行的页面，以减少写回操作。

4. **U (User)**:
该标志位可以用于区分系统和用户数据页面，一些替换算法可能会优先考虑替换用户数据页，以确保系统数据页的稳定性。

5. **G (Global)**:
全局页面通常不参与页替换，因为它们是系统级别的页面。在页替换算法中，可以利用该标志位跳过全局页面，以避免对系统关键数据的替换。

6. **A (Accessed)**:
这是实现 **LRU（最近最少使用）** 或 **Clock** 页替换算法的关键位。通过检查 `A` 位，操作系统可以判断哪些页面最近被使用过，从而选择那些长时间未被访问的页面进行替换。

7. **D (Dirty)**:
页替换算法需要判断页面是否需要写回磁盘。只有 `D` 位为 `1` 的页面需要写回磁盘（脏页），而 `D` 位为 `0` 的页面可以直接丢弃。这样可以优化性能，减少不必要的磁盘写操作。

8. **RSW (Reserved for Software)**:
在现页替换算法时，可以将该字段用于特定的算法需求。例如，可以使用该字段标记页面的替换顺序或优先级，以便在替换时快速找到合适的页面。


### 3.3如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

1. **保存异常地址**：当页访问异常发生时，硬件会将引发异常的虚拟地址保存到 `cr2` 寄存器中，这个寄存器专门用于存储发生页访问异常的地址。操作系统可以通过读取 `cr2` 来确定是哪个地址导致了异常，为后续处理提供信息。

2. **生成错误代码**：接着，硬件会生成一个错误代码来描述异常的具体原因。错误代码中包含了一些标志位，用于指示该页访问异常是因为页面不存在、访问权限不足，还是在内核模式或用户模式下触发的。这个错误代码会传递给操作系统，以帮助其识别异常的类型。

3. **触发 Page Fault 异常**：硬件通过触发 Page Fault 异常（通常是中断号 14）来通知操作系统发生了页访问异常，并将控制权交给操作系统的异常处理程序。这个过程将系统切换到内核模式，使操作系统能够安全地处理异常。

4. **进入 `do_pagefault` 函数处理**：操作系统的异常处理程序接管控制权，调用 `do_pagefault` 函数来处理该页访问异常。在 `do_pagefault` 中，操作系统首先会获取到 `cr2` 寄存器中的地址和错误代码，以确定具体的异常原因。然后，操作系统决定下一步的操作，比如是否加载缺失的页面、更新页表，或是终止试图非法访问内存的进程。


### 3.4数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

`struct Page` 的字段与页表项或页目录项中的字段没有直接对应关系，但其中一些和与页表项或页目录项中的字段有间接对应关系，如下：

1. `int ref` 用于记录该物理页框的引用次数，表示有多少个虚拟地址映射到该物理页框，它间接对应于页表项（PTE），如果有多个虚拟地址（即多个 PTE）指向同一个物理页框，那么 `ref` 的值会大于 1。

2. `uint_t flags`（状态标志）用于存储描述物理页框状态的标志位，例如该页是否有效、是否脏页等。它间接对应于页表项（PTE）中的标志位（如 Valid、Dirty 等位）。

3. `uint_t visited`（访问标志）用于记录该页框是否被访问过，常用于页替换算法（如 LRU 算法）。它间接对应于页表项（PTE）中的 `Accessed` 位，页表项中的 `Accessed` 位（A 位）表示页面是否被访问过。

4. `uintptr_t pra_vaddr` （页面替换虚拟地址）在页面替换算法中，用于记录与该物理页框对应的虚拟地址。它间接对应于页表项（PTE）中的虚拟地址。


## **四、练习4：补充完成Clock页替换算法（需要编程）** 
通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 比较Clock页替换算法和FIFO算法的不同。

## **五、练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）**  
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？
### 4.1 Clock页替换算法的实现
1. `_clock_init_mm` 初始化pra_list_head为空链表，初始化当前指针curr_ptr指向pra_list_head,将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作
```c++
static int
_clock_init_mm(struct mm_struct *mm)
{      
     // 初始化pra_list_head为空链表
     list_init(&pra_list_head);
     // 初始化当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头
     curr_ptr=&pra_list_head;
     // 将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作
     mm->sm_priv = &pra_list_head;
     return 0;
}
```
2. `clock_map_swappable`:将最近到达的页面链接到 pra_list_head 队列的末尾
```c++
static int
_clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
{
    list_entry_t *entry=&(page->pra_page_link);
 
    assert(entry != NULL && curr_ptr != NULL);

    // 将页面page插入到页面链表pra_list_head的末尾
    list_add_before(&pra_list_head, entry);
    // 将页面的visited标志置为1，表示该页面已被访问
    page->visited = 1;
    return 0;
}
```

3. `_clock_swap_out_victim`:从当前节点开始便利链表找到最早没有被访问过的页面，删除该页面
```c++
static int
_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)
{
    list_entry_t *head=(list_entry_t*)mm->sm_priv;
    assert(head != NULL);
    assert(in_tick==0);
    
    while(1){
        // 遍历页面链表pra_list_head，查找最早未被访问的页面
        // 获取当前页面对应的Page结构指针
        if (curr_ptr == &pra_list_head)
        {
            // 遍历回到开始，则再次遍历
            curr_ptr = list_next(curr_ptr);
        }

        struct Page *page = le2page(curr_ptr, pra_page_link);
        // 如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面
        if (page->visited == 0) {
            cprintf("curr_ptr %p\n", curr_ptr);
            list_del(curr_ptr);

            *ptr_page = page;
            //将 curr_ptr 移动到下一个节点
            curr_ptr = list_next(curr_ptr);
            break;
        }
        // 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问
        else{
            page->visited = 0;
            // 将 curr_ptr 移动到下一个节点
            curr_ptr = list_next(curr_ptr);
        }
    }
    return 0;
}
```

### 4.2 Clock页替换算法和FIFO算法的不同
1. 置换策略：
 1. FIFO：不记录页面的访问历史，单纯依据页面进入内存的时间顺序进行操作
 2. Clock：使用visited位记录页面是否被访问，如果被访问过，会延迟置换

2. 代码实现：
 1. `_map_swappable`:FIFO：直接将页面加入到队列尾部. Clock：将页面加入环形链表，并初始化visited位为1
 2. `_swap_out_victim`:FIFO：直接从队列头部移除页面. Clock：逐个检查页面的visited位，直到找到一个未被访问的页面

## **五、练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）**  
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？
在本次实验中页表映射关系的构建主要存在于pmm.c文件中，其中包括了初始化时映射虚拟地址和物理地址并且构建页表项、页表项的获取、物理页面和页表项的映射关系连接、物理页面的删除、页表项的删除等相关处理。

好处：
1. 减少页表项数量：使用大页可以减少页表中的页表项数量，，从而减少了页表所占用的内存空间，降低了存储开销。
2. 减少 TLB 缺失率：大页可以减少 TLB（转换后备缓冲区）的缺失率，提高了内存访问效率，减少了 TLB 的刷新次数，提高了程序的运行效率。
3. 提高内存访问速度：使用大页可以提高内存访问速度，减少了访问页表的次数，从而加快了内存访问的速度，提高了系统的整体性能。

坏处：
1. 内存碎片：使用大页可能会增加内存碎片的产生。如果内存分配不够灵活，可能会导致内存碎片问题，影响系统的内存利用率。
2. 更高的页表更新开销：在某些情况下，使用大页可能会增加页表的更新开销，特别是在需要频繁地对内存进行重新映射时，可能会导致额外的开销。
3. 不适合小型应用：大页不太适合对内存要求较小的应用程序，因为它可能会占用过多的内存空间，造成资源浪费。
4. 不灵活：分级页表可以根据需要动态地添加或删除页表，而一个大页的页表映射方式则需要一开始就分配一个足够大的页表，这样就不够灵活。

因此，在选择是否使用大页时，系统的具体需求和硬件支持必须被综合考虑。

## **六、扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）** 
为详细说明，该LRU页替换算法的设计、分析和测试的实验报告在同目录下的`LRU算法.md`文件中。



