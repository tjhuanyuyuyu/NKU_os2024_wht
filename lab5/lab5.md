### 操作系统lab5实验报告

***

#### 成员：涂佳欢语 王婷睿 胡可玉

***

#### 练习0：填写已有实验

***

本实验依赖实验2/3/4。请把你做的实验2/3/4的代码填入本实验中代码中有“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验2/3/4的代码进行进一步改进。

***

#### 练习1: 加载应用程序并执行（需要编码）

**load_icode()** 函数在 **do_execv()** 中被调用，实现加载新的程序二进制文件到内存中(设置一个新的进程地址空间，加载可执行文件的代码和数据，并为进程创建适当的用户栈和其他内存区域)。

下面我们将介绍如何实现 **load_icode()** 函数，练习一包含在该函数中。

***

**load_icode()**

- **函数入口与检查:** 检查当前进程是否已经拥有 **mm**。
  - 如果当前进程已经有内存映射，说明进程已经加载了程序或运行过其他任务，调用load_icode会出现错误;
- **创建mm结构:** 利用 **mm_create()** 为当前进程创建一个新的 **mm_struct**;
- **创建新的页表目录:** 调用 **setup_pgdir()** 为当前进程设置新的页表目录;
- **解析 ELF 文件并加载程序段:**
  
   - 将 **ELF** 文件的 **二进制数据** 转换为**elfhdr**，并根据 **elfhdr** 中的 **e_phoff字段** 定位 **proghdr** 的位置;
   - 遍历 **proghdr** 并加载需要的 **段**;
   - 设置虚拟内存权限,且调用 **mm_map** 函数为 **段** 分配虚拟内存空间;
   - 复制 **程序段** 数据到内存;
   - 处理 **BSS** 段,将对应的内存区域清零。memset 用于将内存填充为零。
  
- **为用户栈分配内存:** 设置进程的内存管理结构和页表
   - 将新的 **mm** 设置为当前进程的内存管理结构，并更新进程的页表地址 cr3 寄存器。
- **设置 trapframe 以准备用户程序执行:**
  - 获取当前进程的 **trapframe** ,清空其内容。
  - 设置trapframe中内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。(即我们需要填充的部分)
  
***

**1.1、设置trapframe内容**

设置trapframe的目的是在执行进程后，能够从应用程序设定的起始执行地址开始执行。

因此填充代码如下：

```c++
tf->gpr.sp = USTACKTOP;
tf->epc = elf->e_entry;
tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);
```

即：将**sp**设置为**用户栈顶**;**epc**设置为**文件的入口地址**，当进程从内核模式返回用户模式时，会从该地址执行;**SSTATUS_SPP**：表示进程当前是否运行在内核模式。通过**清除**该位，提示当前进程即将从内核模式切换到用户模式执行；SPIE位清零，表示不启用中断。

因此通过上述操作可以确保进程从内核模式正确地切换到用户模式并开始执行应用程序的第一条指令。

***

**1.2、请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过**

- 从 **init_main** 中通过 **kernel_thread** 调用 **do_fork** 创建并唤醒线程，使其执行**user_main**，此时该线程状态已经为 **PROC_RUNNABLE**，表明该线程开始运行;
- **user_main** 中通过宏 **KERNEL_EXECVE** ，调用**kernel_execve**,从而触发内核模式的操作来加载用户程序;
- 在 **kernel_execve** 中执行 **ebreak**，发生断点异常，进入__alltraps，再进入trap，到trap_dispatch，然后到exception_handler，最后到CAUSE_BREAKPOINT；（进程在内核态运行，而不再执行 user_main 中的代码）
- 在 **CAUSE_BREAKPOINT** 处调用 **syscall**，此后操作是为用户程序准备环境，加载代码和数据等;
- 在 **syscall** 中根据传入参数，执行 **sys_exec**，调用 **do_execve**;
- 在 **do_execve** 中调用 **load_icode**，加载文件;
- 当用户程序加载完成后一路返回，直到 **__alltraps** 的末尾，接着执行 **__trapret** 后的内容，到 **sret**，表示退出S态，回到用户态执行，这时开始执行用户的应用程序;

根据上述操作，进程返回用户态并开始执行用户程序的第一条指令。此时控制流从user_main跳到了用户程序的入口点。user_main完成启动用户程序并切换到内核态加载程序的任务。

#### 练习2: 父进程复制自己的内存空间给子进程（需要编码）

先说明这个函数被调用的流程：

```
+------------+    +-------------+    +-------------+    +-------------+
|   do_fork  | -> |   copy_mm   | -> |  dup_mmap   | -> | copy_range  |
+------------+    +-------------+    +-------------+    +-------------+
```

1. `do_fork` 函数用于创建一个新进程。首先，它检查系统是否可以分配新进程并为新进程分配进程控制块（PCB）和内核栈。如果分配成功，接下来会调用 `copy_mm` 函数来复制当前进程的内存空间到新进程。完成内存复制后，`do_fork` 继续复制线程上下文，设置新进程的 PID，更新进程表，并激活新进程。

2. `copy_mm` 函数用于为新进程复制内存空间，在创建子进程时，它会根据 `clone_flags` 决定是共享内存还是复制内存。如果没有设置 `CLONE_VM` 标志，则需要为子进程创建一个新的内存描述符，并调用 `dup_mmap` 函数来复制父进程的内存映射。成功执行后，`copy_mm` 会继续设置新进程的页表和其他内存相关信息。

3. `dup_mmap` 函数负责将父进程的虚拟内存区域映射复制到子进程中。它首先遍历父进程的虚拟内存区域链表，为每个虚拟内存区域（VMA）创建一个新的副本，并使用 `copy_range` 函数将父进程对应的内存页复制到子进程的页表中，通过设置 `share` 为 `0`，表示子进程将拥有独立的物理内存页，而不是与父进程共享，这保证了子进程在创建时有自己的内存空间，从而实现内存的隔离。总体而言，`dup_mmap` 通过复制虚拟内存区域和物理内存页，确保了子进程在内存布局上与父进程相似，但具有独立的物理内存。

接下来就到了我们需要补充完整的函数 `copy_range` ， 它的作用是将一个内存范围的内容从一个进程的页表（`from`）复制到另一个进程的页表（`to`），并且支持是否共享页的选项。

**参数说明**：
- `pde_t *to`：目标进程的页目录表。
- `pde_t *from`：源进程的页目录表。
- `uintptr_t start`：复制开始的虚拟地址。
- `uintptr_t end`：复制结束的虚拟地址。
- `bool share`：是否共享页，影响页表映射的方式。

**步骤说明**：
1. **验证参数**
   ```c
   assert(start % PGSIZE == 0 && end % PGSIZE == 0);
   assert(USER_ACCESS(start, end));
   ```
   - `start` 和 `end` 必须是页面大小（`PGSIZE`）的整数倍，确保地址对齐。
   - `USER_ACCESS(start, end)` 检查指定的虚拟地址范围是否在用户可访问的范围内。

2. **复制内容（按页面单位）**
   ```c
   do {
       // 获取源进程指定地址的页表项
       pte_t *ptep = get_pte(from, start, 0), *nptep;
       if (ptep == NULL) {
           start = ROUNDDOWN(start + PTSIZE, PTSIZE);
           continue;
       }
   ```
   - 使用 `get_pte` 获取源进程在 `start` 地址的页表项（`ptep`）。如果页表项为空，表示该页没有映射，`start` 地址向上调整到下一个页目录项，并继续处理下一个地址范围。

3. **检查页表项的有效性**
   ```c
   if (*ptep & PTE_V) {
       if ((nptep = get_pte(to, start, 1)) == NULL) {
           return -E_NO_MEM;
       }
   ```
   - 如果页表项有效（`PTE_V` 表示该页有效），则获取目标进程的页表项 `nptep`，并确保如果目标页表项为空，则分配一个新的页表项。如果无法分配内存（`get_pte` 返回 `NULL`），则返回 `-E_NO_MEM` 错误。

4. **获取源页和目标页**
   ```c
   uint32_t perm = (*ptep & PTE_USER);
   struct Page *page = pte2page(*ptep);  // 源进程的物理页面
   struct Page *npage = alloc_page();    // 为目标进程分配一个新页面
   assert(page != NULL);
   assert(npage != NULL);
   ```
   - 提取源进程的页面权限（`PTE_USER`）并从源进程的页表项中获取物理页面（`page`）。
   - 为目标进程分配一个新的页面（`npage`）用于存放复制的内容。

5. **复制内存内容并建立页表映射**
   这一部分需要复制内存内容并建立页表映射，也是需要我们填写的部分，我们将分四步来完成，分别是：
   - 获取源页面的内核虚拟地址
   - 获取目标页面的内核虚拟地址
   - 进行内存拷贝，拷贝大小为 PGSIZE
   - 将目标页面映射到目标虚拟地址

   ```c
   int ret = 0;
   // (1) 获取源页面的内核虚拟地址
   uintptr_t *src_kvaddr = page2kva(page);
   // (2) 获取目标页面的内核虚拟地址
   uintptr_t *dst_kvaddr = page2kva(npage);
   // (3) 进行内存拷贝，拷贝大小为 PGSIZE
   memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
   // (4) 将目标页面映射到目标虚拟地址
   ret = page_insert(to, npage, start, perm);
   assert(ret == 0);
   ```

   - `(1)` 获取源页面的内核虚拟地址，通过 `page2kva(page)`，`page2kva(struct Page *page)`是在`pmm.h`中定义的内联函数，它的参数是一个页指针，它返回由 `page` 管理的内存的内核虚拟地址
   - `(2)` 获取目标页面的内核虚拟地址，同样通过 `page2kva(npage)`。
   - `(3)` 使用 `memcpy` 将源页面的内容复制到目标页面，复制的大小为 `PGSIZE`，`memcpy`是典型的内存复制函数。
   - `(4)` 使用 `page_insert` 将目标页面（`npage`）的物理地址映射到目标进程的起始虚拟地址 `start`，并设置权限为原页面的权限（`perm`），`to` 是目标进程的页目录表，`page_insert`函数用于将物理地址与虚拟地址建立映射。


6. **调整地址并继续复制**
   ```c
   start += PGSIZE;
   } while (start != 0 && start < end);
   return 0;
   ```
   - 每次处理完一个页面后，将 `start` 地址增加 `PGSIZE`，继续处理下一个页面，直到整个地址范围被处理完毕。

下面给出COW机制的设计：

 Copy-on-write (COW) 机制的核心思想是延迟内存页的复制，只有在某个进程尝试写入一个共享内存页时，才会进行实际的内存复制。

1. 资源共享:当多个任务读取同一资源时，它们共享对该资源的访问，而不是复制资源，比如在do_fork时，将父进程的所有页表项设置为只读，在新进程的结构中只复制栈和虚拟内存的页表，不为其分配新的页，可以通过copy_mm的`clone_flags`参数实现，`clone_flags` 决定是共享内存还是复制内存，我们直接设置其为真，这样子进程将直接继承父进程的虚拟内存管理结构 mm_struct，实现共享内存。

2. 检测写操作:当一个子进程试图写入共享资源时，系统需要捕获这个操作。通过内存保护硬件实现，当任务试图写入一个标记为只读的内存区域时，硬件触发一个异常。可以通过定义一个新的trap类型，然后到trap.c的exception handler中对应处理。

3. 资源复制:当系统捕获到写操作时，它会分配新的内存或磁盘空间，并将原始资源的内容复制到新分配的空间中。可以调用copy_range实现。

4. 更新指针和页表项:系统将试图写入资源的任务的指针更新为指向新复制的资源，更新页表项，然后允许写操作继续进行。这样写操作只影响新复制的资源，而不影响其他任务看到的原始资源。

#### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
**1. fork/exec/wait/exit函数分析：** 
用户进程不能执行特权指令，即使直接调用函数后也不能进行用户态和内核态的上下文切换。所以在实验中我们借助中断处理来完成上下文切换，在用户态中通过ebreak产生断点中断，进一步调用
```c++
与进程相关的系统调用：
   - SYS_exit        : 进程退出，                           --> do_exit
   - SYS_fork        : 创建子进程，复制内存管理（mm）        --> do_fork --> wakeup_proc
   - SYS_wait        : 等待进程                              --> do_wait
   - SYS_exec        : 在 fork 后，进程执行程序               --> 加载程序并刷新内存管理（mm）
   - SYS_clone       : 创建子线程                           --> do_fork --> wakeup_proc
   - SYS_yield       : 进程标记自己需要重新调度，            --> proc->need_sched = 1, 然后调度器会重新调度该进程
   - SYS_sleep       : 进程进入睡眠状态                      --> do_sleep
   - SYS_kill        : 终止进程                              --> do_kill --> proc->flags |= PF_EXITING
                                                               --> wakeup_proc --> do_wait --> do_exit
   - SYS_getpid      : 获取进程的进程 ID（PID）
```

1.  `fork()`用于创建一个新的子进程
    1. 执行流程：fork()->sys_fork()->syscall(SYS_fork)->trap->syscall()->sys_fork()->do_fork()
    2. 首先是由用户调用用户进程的fork函数，fork函数会调用用户进程中的sys_fork函数，以调用编号为参数，进入sys_fork函数后会调用ecall（通过触发异常，进入trap.c中的CAUSE_USER_ECALL）进入内核态，之后通过调用内核中的syscall函数，根据tf中传递的参数知道需要进行的操作。SYS_fork是对应到内核态中的sys_fork（）函数，将tf和stack作为参数调用do_fork函数，执行对应的操作。由此来完成内核态和用户态程序的交错执行
    3. `do_fork()`
       1. 分配并初始化进程控制块(alloc_proc 函数);
       2、分配并初始化内核栈(setup_stack 函数);
       3、根据 clone_flag标志复制或共享进程内存管理结构(copy_mm 函数);
       4、设置进程在内核(将来也包括用户态)正常运行和调度所需的中断帧和执行上下文(copy_thread 函数);
       5、把设置好的进程控制块放入hash_list 和 proc_list 两个全局进程链表中;
       6、自此,进程已经准备好执行了,把进程状态设置为“就绪”态;
       7、设置返回码为子进程的 id 号。
      - 
2.  `exec()`用于在当前进程中加载并执行一个新程序
    1.  执行流程：和fork相似，将syscall中参数修改为SYS_exec。
    2.  该函数也是在sys_fork函数后调用ecall之前都处于用户态，之后在内核态中实现相关操作。根据用户态中传来的参数，内核态找到对应的sys_exec()函数，通过传入的名字、长度、二进制文件、大小作为函数参数来调用真正执行操作的do_execve函数。
    3.  `do_exec()`
        1.  首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。
        2. 接下来是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。之后就是调用load_icode从而使之准备好执行。
3.  `wait()`
    1.  执行流程同上。
    2.  `do_wait()`
        1.  如果 pid!=0，表示只找一个进程 id 号为 pid 的退出状态的子进程，否则找任意一个处于退出状态的子进程;
        2.  如果此子进程的执行状态不为PROC_ZOMBIE，表明此子进程还没有退出，则当前进程设置执行状态为PROC_SLEEPING（睡眠），睡眠原因为WT_CHILD(即等待子进程退出)，调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤 1 处执行;
        3.  如果此子进程的执行状态为 PROC_ZOMBIE，表明此子进程处于退出状态，需要当前进程(即子进程的父进程)完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列proc_list和hash_list中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，它所占用的所有资源均已释放。

4.  `exit()`
    1. 执行流程同上。
    2. `do_exit()`
       1.  先判断是否是用户进程，如果是，则开始回收此用户进程所占用的用户态虚拟内存空间;（具体的回收过程不作详细说明）
       2.  设置当前进程的中hi性状态为PROC_ZOMBIE，然后设置当前进程的退出码为error_code。表明此时这个进程已经无法再被调度了，只能等待父进程来完成最后的回收工作（主要是回收该子进程的内核栈、进程控制块）
       3.  如果当前父进程已经处于等待子进程的状态，即父进程的wait_state被置为WT_CHILD，则此时就可以唤醒父进程，让父进程来帮子进程完成最后的资源回收工作。
       4.  如果当前进程还有子进程,则需要把这些子进程的父进程指针设置为内核线程init,且各个子进程指针需要插入到init的子进程链表中。如果某个子进程的执行状态是 PROC_ZOMBIE,则需要唤醒 init来完成对此子进程的最后回收工作。
       5.  执行schedule()调度函数，选择新的进程执行。

**2. ucore中一个用户态进程的执行状态生命周期图：**  
```
      (alloc_proc)                (wakeup_proc)                   (do_wait)
    ---------------> PROC_UNINIT ---------------> PROC_RUNNABLE -------------> PROC_SLEEPING
                                                      |                          |
                                                      |                          |
                                                      | (do_exit)                |(do_exit)
                                                      |                          |
                                                      V                          |
                                                   PROC_ZOMBIE <------------------
```
***

#### 扩展练习 Challenge

***

1、实现 Copy on Write （COW）机制

***

2、说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？
