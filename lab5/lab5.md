### 操作系统lab5实验报告

***

#### 成员：涂佳欢语 王婷睿 胡可玉

***

#### 练习0：填写已有实验

***

本实验依赖实验2/3/4。请把你做的实验2/3/4的代码填入本实验中代码中有“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验2/3/4的代码进行进一步改进。

***

#### 练习1: 加载应用程序并执行（需要编码）

**load_icode()** 函数在 **do_execv()** 中被调用，实现加载新的程序二进制文件到内存中(设置一个新的进程地址空间，加载可执行文件的代码和数据，并为进程创建适当的用户栈和其他内存区域)。

下面我们将介绍如何实现 **load_icode()** 函数，练习一包含在该函数中。

***

**load_icode()**

- **函数入口与检查:** 检查当前进程是否已经拥有 **mm**。
  - 如果当前进程已经有内存映射，说明进程已经加载了程序或运行过其他任务，调用load_icode会出现错误;
- **创建mm结构:** 利用 **mm_create()** 为当前进程创建一个新的 **mm_struct**;
- **创建新的页表目录:** 调用 **setup_pgdir()** 为当前进程设置新的页表目录;
- **解析 ELF 文件并加载程序段:**
  
   - 将 **ELF** 文件的 **二进制数据** 转换为**elfhdr**，并根据 **elfhdr** 中的 **e_phoff字段** 定位 **proghdr** 的位置;
   - 遍历 **proghdr** 并加载需要的 **段**;
   - 设置虚拟内存权限,且调用 **mm_map** 函数为 **段** 分配虚拟内存空间;
   - 复制 **程序段** 数据到内存;
   - 处理 **BSS** 段,将对应的内存区域清零。memset 用于将内存填充为零。
  
- **为用户栈分配内存:** 设置进程的内存管理结构和页表
   - 将新的 **mm** 设置为当前进程的内存管理结构，并更新进程的页表地址 cr3 寄存器。
- **设置 trapframe 以准备用户程序执行:**
  - 获取当前进程的 **trapframe** ,清空其内容。
  - 设置trapframe中内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。(即我们需要填充的部分)
  
***

**1.1、设置trapframe内容**

设置trapframe的目的是在执行进程后，能够从应用程序设定的起始执行地址开始执行。

因此填充代码如下：

```c++
tf->gpr.sp = USTACKTOP;
tf->epc = elf->e_entry;
tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);
```

即：将**sp**设置为**用户栈顶**;**epc**设置为**文件的入口地址**，当进程从内核模式返回用户模式时，会从该地址执行;**SSTATUS_SPP**：表示进程当前是否运行在内核模式。通过**清除**该位，提示当前进程即将从内核模式切换到用户模式执行；SPIE位清零，表示不启用中断。

因此通过上述操作可以确保进程从内核模式正确地切换到用户模式并开始执行应用程序的第一条指令。

***

**1.2、请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过**

- 从 **init_main** 中通过 **kernel_thread** 调用 **do_fork** 创建并唤醒线程，使其执行**user_main**，此时该线程状态已经为 **PROC_RUNNABLE**，表明该线程开始运行;
- **user_main** 中通过宏 **KERNEL_EXECVE** ，调用**kernel_execve**,从而触发内核模式的操作来加载用户程序;
- 在 **kernel_execve** 中执行 **ebreak**，发生断点异常，进入__alltraps，再进入trap，到trap_dispatch，然后到exception_handler，最后到CAUSE_BREAKPOINT；（进程在内核态运行，而不再执行 user_main 中的代码）
- 在 **CAUSE_BREAKPOINT** 处调用 **syscall**，此后操作是为用户程序准备环境，加载代码和数据等;
- 在 **syscall** 中根据传入参数，执行 **sys_exec**，调用 **do_execve**;
- 在 **do_execve** 中调用 **load_icode**，加载文件;
- 当用户程序加载完成后一路返回，直到 **__alltraps** 的末尾，接着执行 **__trapret** 后的内容，到 **sret**，表示退出S态，回到用户态执行，这时开始执行用户的应用程序;

根据上述操作，进程返回用户态并开始执行用户程序的第一条指令。此时控制流从user_main跳到了用户程序的入口点。user_main完成启动用户程序并切换到内核态加载程序的任务。

#### 练习2: 父进程复制自己的内存空间给子进程（需要编码）

先说明这个函数被调用的流程：

```
+------------+    +-------------+    +-------------+    +-------------+
|   do_fork  | -> |   copy_mm   | -> |  dup_mmap   | -> | copy_range  |
+------------+    +-------------+    +-------------+    +-------------+
```

1. `do_fork` 函数用于创建一个新进程。首先，它检查系统是否可以分配新进程并为新进程分配进程控制块（PCB）和内核栈。如果分配成功，接下来会调用 `copy_mm` 函数来复制当前进程的内存空间到新进程。完成内存复制后，`do_fork` 继续复制线程上下文，设置新进程的 PID，更新进程表，并激活新进程。

2. `copy_mm` 函数用于为新进程复制内存空间，在创建子进程时，它会根据 `clone_flags` 决定是共享内存还是复制内存。如果没有设置 `CLONE_VM` 标志，则需要为子进程创建一个新的内存描述符，并调用 `dup_mmap` 函数来复制父进程的内存映射。成功执行后，`copy_mm` 会继续设置新进程的页表和其他内存相关信息。

3. `dup_mmap` 函数负责将父进程的虚拟内存区域映射复制到子进程中。它首先遍历父进程的虚拟内存区域链表，为每个虚拟内存区域（VMA）创建一个新的副本，并使用 `copy_range` 函数将父进程对应的内存页复制到子进程的页表中，通过设置 `share` 为 `0`，表示子进程将拥有独立的物理内存页，而不是与父进程共享，这保证了子进程在创建时有自己的内存空间，从而实现内存的隔离。总体而言，`dup_mmap` 通过复制虚拟内存区域和物理内存页，确保了子进程在内存布局上与父进程相似，但具有独立的物理内存。

接下来就到了我们需要补充完整的函数 `copy_range` ， 它的作用是将一个内存范围的内容从一个进程的页表（`from`）复制到另一个进程的页表（`to`），并且支持是否共享页的选项。

**参数说明**：
- `pde_t *to`：目标进程的页目录表。
- `pde_t *from`：源进程的页目录表。
- `uintptr_t start`：复制开始的虚拟地址。
- `uintptr_t end`：复制结束的虚拟地址。
- `bool share`：是否共享页，影响页表映射的方式。

**步骤说明**：
1. **验证参数**
   ```c
   assert(start % PGSIZE == 0 && end % PGSIZE == 0);
   assert(USER_ACCESS(start, end));
   ```
   - `start` 和 `end` 必须是页面大小（`PGSIZE`）的整数倍，确保地址对齐。
   - `USER_ACCESS(start, end)` 检查指定的虚拟地址范围是否在用户可访问的范围内。

2. **复制内容（按页面单位）**
   ```c
   do {
       // 获取源进程指定地址的页表项
       pte_t *ptep = get_pte(from, start, 0), *nptep;
       if (ptep == NULL) {
           start = ROUNDDOWN(start + PTSIZE, PTSIZE);
           continue;
       }
   ```
   - 使用 `get_pte` 获取源进程在 `start` 地址的页表项（`ptep`）。如果页表项为空，表示该页没有映射，`start` 地址向上调整到下一个页目录项，并继续处理下一个地址范围。

3. **检查页表项的有效性**
   ```c
   if (*ptep & PTE_V) {
       if ((nptep = get_pte(to, start, 1)) == NULL) {
           return -E_NO_MEM;
       }
   ```
   - 如果页表项有效（`PTE_V` 表示该页有效），则获取目标进程的页表项 `nptep`，并确保如果目标页表项为空，则分配一个新的页表项。如果无法分配内存（`get_pte` 返回 `NULL`），则返回 `-E_NO_MEM` 错误。

4. **获取源页和目标页**
   ```c
   uint32_t perm = (*ptep & PTE_USER);
   struct Page *page = pte2page(*ptep);  // 源进程的物理页面
   struct Page *npage = alloc_page();    // 为目标进程分配一个新页面
   assert(page != NULL);
   assert(npage != NULL);
   ```
   - 提取源进程的页面权限（`PTE_USER`）并从源进程的页表项中获取物理页面（`page`）。
   - 为目标进程分配一个新的页面（`npage`）用于存放复制的内容。

5. **复制内存内容并建立页表映射**
   这一部分需要复制内存内容并建立页表映射，也是需要我们填写的部分，我们将分四步来完成，分别是：
   - 获取源页面的内核虚拟地址
   - 获取目标页面的内核虚拟地址
   - 进行内存拷贝，拷贝大小为 PGSIZE
   - 将目标页面映射到目标虚拟地址

   ```c
   int ret = 0;
   // (1) 获取源页面的内核虚拟地址
   uintptr_t *src_kvaddr = page2kva(page);
   // (2) 获取目标页面的内核虚拟地址
   uintptr_t *dst_kvaddr = page2kva(npage);
   // (3) 进行内存拷贝，拷贝大小为 PGSIZE
   memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
   // (4) 将目标页面映射到目标虚拟地址
   ret = page_insert(to, npage, start, perm);
   assert(ret == 0);
   ```

   - `(1)` 获取源页面的内核虚拟地址，通过 `page2kva(page)`，`page2kva(struct Page *page)`是在`pmm.h`中定义的内联函数，它的参数是一个页指针，它返回由 `page` 管理的内存的内核虚拟地址
   - `(2)` 获取目标页面的内核虚拟地址，同样通过 `page2kva(npage)`。
   - `(3)` 使用 `memcpy` 将源页面的内容复制到目标页面，复制的大小为 `PGSIZE`，`memcpy`是典型的内存复制函数。
   - `(4)` 使用 `page_insert` 将目标页面（`npage`）的物理地址映射到目标进程的起始虚拟地址 `start`，并设置权限为原页面的权限（`perm`），`to` 是目标进程的页目录表，`page_insert`函数用于将物理地址与虚拟地址建立映射。


6. **调整地址并继续复制**
   ```c
   start += PGSIZE;
   } while (start != 0 && start < end);
   return 0;
   ```
   - 每次处理完一个页面后，将 `start` 地址增加 `PGSIZE`，继续处理下一个页面，直到整个地址范围被处理完毕。



#### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

***

#### 扩展练习 Challenge

***

1、实现 Copy on Write （COW）机制

***

2、说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？
