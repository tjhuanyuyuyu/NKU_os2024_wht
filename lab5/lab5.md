### 操作系统lab5实验报告

***

#### 成员：涂佳欢语 王婷睿 胡可玉

***

#### 练习0：填写已有实验

***

本实验依赖实验2/3/4。请把你做的实验2/3/4的代码填入本实验中代码中有“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验2/3/4的代码进行进一步改进。

***

#### 练习1: 加载应用程序并执行（需要编码）

**load_icode()** 函数在 **do_execv()** 中被调用，实现加载新的程序二进制文件到内存中(设置一个新的进程地址空间，加载可执行文件的代码和数据，并为进程创建适当的用户栈和其他内存区域)。

下面我们将介绍如何实现 **load_icode()** 函数，练习一包含在该函数中。

***

**load_icode()**

- **函数入口与检查:** 检查当前进程是否已经拥有 **mm**。
  - 如果当前进程已经有内存映射，说明进程已经加载了程序或运行过其他任务，调用load_icode会出现错误;
- **创建mm结构:** 利用 **mm_create()** 为当前进程创建一个新的 **mm_struct**;
- **创建新的页表目录:** 调用 **setup_pgdir()** 为当前进程设置新的页表目录;
- **解析 ELF 文件并加载程序段:**
  
   - 将 **ELF** 文件的 **二进制数据** 转换为**elfhdr**，并根据 **elfhdr** 中的 **e_phoff字段** 定位 **proghdr** 的位置;
   - 遍历 **proghdr** 并加载需要的 **段**;
   - 设置虚拟内存权限,且调用 **mm_map** 函数为 **段** 分配虚拟内存空间;
   - 复制 **程序段** 数据到内存;
   - 处理 **BSS** 段,将对应的内存区域清零。memset 用于将内存填充为零。
  
- **为用户栈分配内存:** 设置进程的内存管理结构和页表
   - 将新的 **mm** 设置为当前进程的内存管理结构，并更新进程的页表地址 cr3 寄存器。
- **设置 trapframe 以准备用户程序执行:**
  - 获取当前进程的 **trapframe** ,清空其内容。
  - 设置trapframe中内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。(即我们需要填充的部分)
  
***

**1.1、设置trapframe内容**

设置trapframe的目的是在执行进程后，能够从应用程序设定的起始执行地址开始执行。

因此填充代码如下：

```c++
tf->gpr.sp = USTACKTOP;
tf->epc = elf->e_entry;
tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);
```

即：将**sp**设置为**用户栈顶**;**epc**设置为**文件的入口地址**，当进程从内核模式返回用户模式时，会从该地址执行;**SSTATUS_SPP**：表示进程当前是否运行在内核模式。通过**清除**该位，提示当前进程即将从内核模式切换到用户模式执行；SPIE位清零，表示不启用中断。

因此通过上述操作可以确保进程从内核模式正确地切换到用户模式并开始执行应用程序的第一条指令。

***

**1.2、请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过**

- 从 **init_main** 中通过 **kernel_thread** 调用 **do_fork** 创建并唤醒线程，使其执行**user_main**，此时该线程状态已经为 **PROC_RUNNABLE**，表明该线程开始运行;
- **user_main** 中通过宏 **KERNEL_EXECVE** ，调用**kernel_execve**,从而触发内核模式的操作来加载用户程序;
- 在 **kernel_execve** 中执行 **ebreak**，发生断点异常，进入__alltraps，再进入trap，到trap_dispatch，然后到exception_handler，最后到CAUSE_BREAKPOINT；（进程在内核态运行，而不再执行 user_main 中的代码）
- 在 **CAUSE_BREAKPOINT** 处调用 **syscall**，此后操作是为用户程序准备环境，加载代码和数据等;
- 在 **syscall** 中根据传入参数，执行 **sys_exec**，调用 **do_execve**;
- 在 **do_execve** 中调用 **load_icode**，加载文件;
- 当用户程序加载完成后一路返回，直到**__alltraps**的末尾，接着执行 **__trapret** 后的内容，到 **sret**，表示退出S态，回到用户态执行，这时开始执行用户的应用程序;

根据上述操作，进程返回用户态并开始执行用户程序的第一条指令。此时控制流从user_main跳到了用户程序的入口点。user_main完成启动用户程序并切换到内核态加载程序的任务。

#### 练习2: 父进程复制自己的内存空间给子进程（需要编码）

***

#### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

***

#### 扩展练习 Challenge

***

1、实现 Copy on Write （COW）机制

***

2、说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？